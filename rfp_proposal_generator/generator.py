import os
from typing import Optional # Added for openai_api_key type hint
from .parsers.rfp_parser import RFPParser
from .agents.rfp_reviewer_agent import RFPReviewerAgent
from .agents.technical_writer_agent import TechnicalWriterAgent
from .agents.formatting_agent import FormattingAgent
from .models.rfp_models import RFP
from .models.proposal_models import Proposal, Introduction, ExecutiveSummary #, TechnicalSolution, TeamQualifications, Pricing

# For now, other proposal sections like Introduction, Executive Summary, TeamQ, Pricing
# will be simple placeholders or manually crafted if not generated by a dedicated agent.

class ProposalGenerator:
    def __init__(self, openai_api_key: Optional[str] = None, llm_model_name: str = "openai:gpt-3.5-turbo"):
        # If API key is provided, set it as an environment variable for pydantic-ai
        # This allows direct key passing if preferred over .env files for some use cases.
        if openai_api_key:
            os.environ["OPENAI_API_KEY"] = openai_api_key

        # Ensure API key is available (either from .env or passed directly)
        # Agents themselves also check for this, but good to have a central check.
        current_api_key = os.getenv("OPENAI_API_KEY")
        if not current_api_key:
            from dotenv import load_dotenv
            if not load_dotenv() and not current_api_key: # Try loading .env if key not already in env
                 # If load_dotenv() is False (no .env or failed) AND current_api_key is still None
                 raise ValueError("OPENAI_API_KEY not found. Please set it in .env or pass it to ProposalGenerator.")
            # Re-check after attempting to load .env
            if not os.getenv("OPENAI_API_KEY"):
                 raise ValueError("OPENAI_API_KEY not found after .env attempt. Please set it in .env or pass it to ProposalGenerator.")


        self.rfp_parser = None # Instantiated per file
        # Agents now get model_name from their own defaults or AgentBase, ensure consistency if needed
        self.rfp_reviewer_agent = RFPReviewerAgent(llm_model_name=llm_model_name)
        self.technical_writer_agent = TechnicalWriterAgent(model_name=llm_model_name)
        self.formatting_agent = FormattingAgent()

    async def generate_proposal(self, rfp_file_path: str, target_technology: str) -> str:
        '''
        Orchestrates the proposal generation process.

        Args:
            rfp_file_path: Path to the RFP file (PDF or Markdown).
            target_technology: The technology to be featured in the proposal.

        Returns:
            A Markdown string representing the generated proposal.
        '''
        print(f"Starting proposal generation for RFP: {rfp_file_path} using technology: {target_technology}")

        # 1. Parse RFP
        print("Step 1: Parsing RFP...")
        self.rfp_parser = RFPParser(file_path=rfp_file_path)
        parsed_rfp_doc: RFP = self.rfp_parser.parse()
        if not parsed_rfp_doc.full_text or not parsed_rfp_doc.full_text.strip():
            raise ValueError(f"Failed to parse content from RFP file: {rfp_file_path}. Full text is empty.")
        print(f"RFP parsed. Extracted text length: {len(parsed_rfp_doc.full_text)}")

        # 2. Review RFP with AI Agent
        print("Step 2: Reviewing RFP with RFPReviewerAgent...")
        # The RFP object is updated in place by the reviewer agent
        reviewed_rfp_doc = await self.rfp_reviewer_agent.review_rfp(parsed_rfp_doc)
        if not reviewed_rfp_doc.summary or not reviewed_rfp_doc.key_requirements:
            print("Warning: RFP review did not yield a summary or key requirements. Proceeding with available data.")
            # Depending on strictness, one might raise an error here.
            # For now, if key_requirements are missing, the next step will fail.
        else:
            print(f"RFP review complete. Summary: {reviewed_rfp_doc.summary[:100]}...")
            print(f"Key Requirements: {reviewed_rfp_doc.key_requirements[:2]}...")


        # 3. Generate Technical Solution with AI Agent
        print("Step 3: Generating Technical Solution with TechnicalWriterAgent...")
        if not reviewed_rfp_doc.key_requirements: # Check specifically for key_requirements
             raise ValueError("Cannot generate technical solution without key requirements from RFP review.")


        technical_solution_section = await self.technical_writer_agent.generate_technical_solution(
            key_requirements=reviewed_rfp_doc.key_requirements,
            chosen_technology=target_technology,
            rfp_summary=reviewed_rfp_doc.summary
        )
        print("Technical solution generated.")

        # 4. Assemble Proposal Pydantic Model
        # For now, Introduction and Executive Summary are simple placeholders.
        # These could be generated by other specialized agents or templated.
        print("Step 4: Assembling proposal document...")
        proposal_introduction = Introduction(
            content=f"This proposal outlines a solution for the project described in {parsed_rfp_doc.file_name if parsed_rfp_doc.file_name else 'the referenced RFP'}, "
                    f"leveraging {target_technology} to meet your needs."
        )

        proposal_executive_summary = ExecutiveSummary(
            content=f"We propose a robust solution based on {target_technology} to address the key requirements "
                    f"identified in the RFP. Our approach focuses on quality, efficiency, and innovation. "
                    f"The core of our proposal is detailed in the technical solution section. "
                    f"Summary of RFP: {reviewed_rfp_doc.summary if reviewed_rfp_doc.summary else 'N/A'}"
        )

        # Other sections like TeamQualifications and Pricing would be similar placeholders or from other agents
        # team_qualifications_section = TeamQualifications(content="[Standard Company Qualifications Placeholder]")
        # pricing_section = Pricing(content="[Standard Pricing Information Placeholder - Details TBD]")

        final_proposal_model = Proposal(
            rfp_reference_document=parsed_rfp_doc.file_name,
            target_technology=target_technology,
            introduction=proposal_introduction,
            executive_summary=proposal_executive_summary,
            technical_solution=technical_solution_section,
            # team_qualifications=team_qualifications_section, # Add if you have placeholder/agent
            # pricing=pricing_section # Add if you have placeholder/agent
        )
        print("Proposal model assembled.")

        # 5. Format Proposal to Markdown
        print("Step 5: Formatting proposal to Markdown...")
        markdown_proposal = self.formatting_agent.format_proposal_to_markdown(final_proposal_model)
        print("Proposal formatted to Markdown successfully.")

        return markdown_proposal

if __name__ == '__main__':
    # Example usage of the ProposalGenerator
    # This requires:
    # - An OPENAI_API_KEY in your .env file (in the project root)
    # - An example RFP file (e.g., examples/rfps/sample.md created in a previous step)
    import asyncio # Required for async main
    from dotenv import load_dotenv # Required for main

    async def run_generator_test():
        # Ensure examples/rfps/sample.md exists and has some content
        sample_rfp_path = "examples/rfps/sample.md" # Created in parser step
        if not os.path.exists(sample_rfp_path):
            print(f"Error: Sample RFP file not found at {sample_rfp_path}")
            print("Please create it with some content, e.g.:")
            print("# Sample RFP\n## Requirements\n- Must be awesome\n- Must be fast")
            # Create a dummy one if it doesn't exist for the test to run
            os.makedirs(os.path.dirname(sample_rfp_path), exist_ok=True)
            with open(sample_rfp_path, "w", encoding="utf-8") as f:
                f.write("# Sample RFP for Testing\n\n## Introduction\nThis is a test RFP.\n\n## Key Requirements\n- Requirement 1: System must be scalable.\n- Requirement 2: User interface must be intuitive.\n\n## Evaluation Criteria\n- Clarity of proposal.\n- Technical feasibility.")
            print(f"Created dummy {sample_rfp_path} for testing.")


        target_tech = "Python with FastAPI and React"

        print("Attempting to initialize ProposalGenerator...")
        try:
            # It's good practice to load .env at the very start of an application script
            if load_dotenv():
                 print(".env loaded by generator's test harness.")
            else:
                 print("No .env file found by generator's test harness, or it's empty. Relying on existing env vars or agent loading.")


            # Check for API key before instantiation for clarity
            if not os.getenv("OPENAI_API_KEY"):
                print("FATAL: OPENAI_API_KEY not set. Please create a .env file in the project root with your key.")
                return

            generator = ProposalGenerator()
            print("ProposalGenerator initialized.")

            print(f"Generating proposal for {sample_rfp_path} with technology {target_tech}...")
            markdown_output = await generator.generate_proposal(sample_rfp_path, target_tech)

            print("\n========== GENERATED PROPOSAL (Markdown) ==========")
            print(markdown_output)
            print("===================================================")

            # Save to a file for inspection
            output_filename = "examples/proposals/generated_proposal_test.md"
            os.makedirs(os.path.dirname(output_filename), exist_ok=True)
            with open(output_filename, "w", encoding="utf-8") as f:
                f.write(markdown_output)
            print(f"Proposal saved to {output_filename}")

        except ValueError as ve:
            print(f"ValueError during generation: {ve}")
        except ImportError as ie:
            print(f"ImportError: {ie}. Make sure all dependencies are installed and paths are correct.")
        except Exception as e:
            import traceback
            print(f"An unexpected error occurred: {e}")
            print(traceback.format_exc())

    if __name__ == '__main__':
        asyncio.run(run_generator_test())
